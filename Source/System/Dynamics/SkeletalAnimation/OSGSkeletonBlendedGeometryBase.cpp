/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: David Kabala (djkabala@gmail.com)                                *
 *          David Naylor                                                     *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class SkeletonBlendedGeometry!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"



#include "OSGGeometry.h"                // BaseGeometry Class
#include "OSGGeoIntegralProperty.h"     // InternalWeightIndexes Class
#include "OSGGeoVectorProperty.h"       // InternalWeights Class
#include "OSGNode.h"                    // InternalJoints Class

#include "OSGSkeletonBlendedGeometryBase.h"
#include "OSGSkeletonBlendedGeometry.h"

#include <boost/bind.hpp>

#include "OSGEventDetails.h"

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::SkeletonBlendedGeometry
    Controller and drawer for character skinning. For character skinning, the animation engine drives the joints (skeleton) of a skinned character. A SkeletonBlendedGeometry
    describes the associations between the joints and the mesh vertices forming the skin topology. The joints
    influence the transformation of skin mesh vertices according to a controlling algorithm.
    The skinning algorithm blends the influences of neighboring joints according to weighted values.
    The  algorithm transforms points of a geometry with
    the transformations of joint nodes and averages the result using scalar weights. The affected
    geometry is called the skin, the combination of a transform (node) and its corresponding weight is called an
    influence, and the set of influencing nodes (usually a hierarchy) is called a skeleton.
    <br>
    Skinning involves two steps:
    - Preprocessing, known as binding the skeleton to the skin
    - Running the skinning algorithm to modify the shape of the skin as the pose of the skeleton changes

    The results of the pre-processing, or skinning information consists of the following:
    - bind-shape: also called default shape. This is the shape of the skin when it was bound to the skeleton. This includes positions (required) for each corresponding mesh vertex and may optionally include additional vertex attributes.
    - influences: a variable-length lists of node + weight pairs for each mesh vertex.
    - bind-pose: the transforms of all influences at the time of binding. This per-node information is usually represented by a bind-matrix, which is the local-to-world matrix of a node at the time of binding.

    In the skinning algorithm, all transformations are done relative to the bind-pose. This relative transform is
    usually pre-computed for each node in the skeleton and is stored as a skinning matrix.
    To derive the new (skinned) position of a vertex, the skinning matrix of each influencing node transforms
    the bind-shape position of the vertex and the result is averaged using the blending weights.
    The easiest way to derive the skinning matrix is to multiply the current local-to-world matrix of a node by
    the inverse of the node's bind-matrix. This effectively cancels out the bind-pose transform of each node
    and allows us to work in the common object space of the skin.
    <br>
    The binding process usually involves:
    - Storing the current shape of the skin as the bind-shape
    - Computing and storing the bind-matrices

    Generating default blending weights, usually with some fall-off function: the farther a joint is from a
    given vertex, the less it influences it. Also, if a weight is 0, the influence can be omitted.
    After that, the artist is allowed to hand-modify the weights, usually by painting them on the mesh.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Geometry *      SkeletonBlendedGeometryBase::_sfBaseGeometry
    
*/

/*! \var GeoIntegralProperty * SkeletonBlendedGeometryBase::_sfInternalWeightIndexes
    
*/

/*! \var GeoVectorProperty * SkeletonBlendedGeometryBase::_sfInternalWeights
    
*/

/*! \var Node *          SkeletonBlendedGeometryBase::_mfInternalJoints
    
*/

/*! \var Matrix          SkeletonBlendedGeometryBase::_mfInternalJointInvBindTransformations
    
*/

/*! \var Matrix          SkeletonBlendedGeometryBase::_sfBindTransformation
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<SkeletonBlendedGeometry *>::_type("SkeletonBlendedGeometryPtr", "GeometryPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(SkeletonBlendedGeometry *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           SkeletonBlendedGeometry *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           SkeletonBlendedGeometry *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void SkeletonBlendedGeometryBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUnrecGeometryPtr::Description(
        SFUnrecGeometryPtr::getClassType(),
        "BaseGeometry",
        "",
        BaseGeometryFieldId, BaseGeometryFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SkeletonBlendedGeometry::editHandleBaseGeometry),
        static_cast<FieldGetMethodSig >(&SkeletonBlendedGeometry::getHandleBaseGeometry));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoIntegralPropertyPtr::Description(
        SFUnrecChildGeoIntegralPropertyPtr::getClassType(),
        "InternalWeightIndexes",
        "",
        InternalWeightIndexesFieldId, InternalWeightIndexesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SkeletonBlendedGeometry::editHandleInternalWeightIndexes),
        static_cast<FieldGetMethodSig >(&SkeletonBlendedGeometry::getHandleInternalWeightIndexes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "InternalWeights",
        "",
        InternalWeightsFieldId, InternalWeightsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SkeletonBlendedGeometry::editHandleInternalWeights),
        static_cast<FieldGetMethodSig >(&SkeletonBlendedGeometry::getHandleInternalWeights));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "InternalJoints",
        "",
        InternalJointsFieldId, InternalJointsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SkeletonBlendedGeometry::editHandleInternalJoints),
        static_cast<FieldGetMethodSig >(&SkeletonBlendedGeometry::getHandleInternalJoints));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "InternalJointInvBindTransformations",
        "",
        InternalJointInvBindTransformationsFieldId, InternalJointInvBindTransformationsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SkeletonBlendedGeometry::editHandleInternalJointInvBindTransformations),
        static_cast<FieldGetMethodSig >(&SkeletonBlendedGeometry::getHandleInternalJointInvBindTransformations));

    oType.addInitialDesc(pDesc);

    pDesc = new SFMatrix::Description(
        SFMatrix::getClassType(),
        "BindTransformation",
        "",
        BindTransformationFieldId, BindTransformationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SkeletonBlendedGeometry::editHandleBindTransformation),
        static_cast<FieldGetMethodSig >(&SkeletonBlendedGeometry::getHandleBindTransformation));

    oType.addInitialDesc(pDesc);
}


SkeletonBlendedGeometryBase::TypeObject SkeletonBlendedGeometryBase::_type(
    SkeletonBlendedGeometryBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&SkeletonBlendedGeometryBase::createEmptyLocal),
    SkeletonBlendedGeometry::initMethod,
    SkeletonBlendedGeometry::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&SkeletonBlendedGeometry::classDescInserter),
    false,
    0,
    "﻿<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"SkeletonBlendedGeometry\"\n"
    "\tparent=\"Geometry\"\n"
    "    library=\"TBAnimation\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    authors=\"David Kabala (djkabala@gmail.com), David Naylor\"\n"
    ">\n"
    "Controller and drawer for character skinning. For character skinning, the animation engine drives the joints (skeleton) of a skinned character. A SkeletonBlendedGeometry\n"
    "describes the associations between the joints and the mesh vertices forming the skin topology. The joints\n"
    "influence the transformation of skin mesh vertices according to a controlling algorithm.\n"
    "The skinning algorithm blends the influences of neighboring joints according to weighted values.\n"
    "The  algorithm transforms points of a geometry with\n"
    "the transformations of joint nodes and averages the result using scalar weights. The affected\n"
    "geometry is called the skin, the combination of a transform (node) and its corresponding weight is called an\n"
    "influence, and the set of influencing nodes (usually a hierarchy) is called a skeleton.\n"
    "&lt;br&gt;\n"
    "Skinning involves two steps:\n"
    "- Preprocessing, known as binding the skeleton to the skin\n"
    "- Running the skinning algorithm to modify the shape of the skin as the pose of the skeleton changes\n"
    "\n"
    "The results of the pre-processing, or skinning information consists of the following:\n"
    "- bind-shape: also called default shape. This is the shape of the skin when it was bound to the skeleton. This includes positions (required) for each corresponding mesh vertex and may optionally include additional vertex attributes.\n"
    "- influences: a variable-length lists of node + weight pairs for each mesh vertex.\n"
    "- bind-pose: the transforms of all influences at the time of binding. This per-node information is usually represented by a bind-matrix, which is the local-to-world matrix of a node at the time of binding.\n"
    "\n"
    "In the skinning algorithm, all transformations are done relative to the bind-pose. This relative transform is\n"
    "usually pre-computed for each node in the skeleton and is stored as a skinning matrix.\n"
    "To derive the new (skinned) position of a vertex, the skinning matrix of each influencing node transforms\n"
    "the bind-shape position of the vertex and the result is averaged using the blending weights.\n"
    "The easiest way to derive the skinning matrix is to multiply the current local-to-world matrix of a node by\n"
    "the inverse of the node&apos;s bind-matrix. This effectively cancels out the bind-pose transform of each node\n"
    "and allows us to work in the common object space of the skin.\n"
    "&lt;br&gt;\n"
    "The binding process usually involves:\n"
    "- Storing the current shape of the skin as the bind-shape\n"
    "- Computing and storing the bind-matrices\n"
    "\n"
    "Generating default blending weights, usually with some fall-off function: the farther a joint is from a\n"
    "given vertex, the less it influences it. Also, if a weight is 0, the influence can be omitted.\n"
    "After that, the artist is allowed to hand-modify the weights, usually by painting them on the mesh.\n"
    "\t<Field\n"
    "\t\tname=\"BaseGeometry\"\n"
    "\t\ttype=\"Geometry\"\n"
    "        category=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"InternalWeightIndexes\"\n"
    "\t\ttype=\"GeoIntegralProperty\"\n"
    "        category=\"childpointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"protected\"\n"
    "\t\tchildParentType=\"FieldContainer\"\n"
    "\t\tlinkParentField=\"Parents\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"InternalWeights\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "        category=\"childpointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tchildParentType=\"FieldContainer\"\n"
    "\t\tlinkParentField=\"Parents\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"InternalJoints\"\n"
    "\t\ttype=\"Node\"\n"
    "        category=\"pointer\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"InternalJointInvBindTransformations\"\n"
    "\t\ttype=\"Matrix\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"BindTransformation\"\n"
    "\t\ttype=\"Matrix\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"SkeletonChanged\"\n"
    "\t\tdetailsType=\"SkeletonEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "</FieldContainer>\n",
    "Controller and drawer for character skinning. For character skinning, the animation engine drives the joints (skeleton) of a skinned character. A SkeletonBlendedGeometry\n"
    "describes the associations between the joints and the mesh vertices forming the skin topology. The joints\n"
    "influence the transformation of skin mesh vertices according to a controlling algorithm.\n"
    "The skinning algorithm blends the influences of neighboring joints according to weighted values.\n"
    "The  algorithm transforms points of a geometry with\n"
    "the transformations of joint nodes and averages the result using scalar weights. The affected\n"
    "geometry is called the skin, the combination of a transform (node) and its corresponding weight is called an\n"
    "influence, and the set of influencing nodes (usually a hierarchy) is called a skeleton.\n"
    "<br>\n"
    "Skinning involves two steps:\n"
    "- Preprocessing, known as binding the skeleton to the skin\n"
    "- Running the skinning algorithm to modify the shape of the skin as the pose of the skeleton changes\n"
    "\n"
    "The results of the pre-processing, or skinning information consists of the following:\n"
    "- bind-shape: also called default shape. This is the shape of the skin when it was bound to the skeleton. This includes positions (required) for each corresponding mesh vertex and may optionally include additional vertex attributes.\n"
    "- influences: a variable-length lists of node + weight pairs for each mesh vertex.\n"
    "- bind-pose: the transforms of all influences at the time of binding. This per-node information is usually represented by a bind-matrix, which is the local-to-world matrix of a node at the time of binding.\n"
    "\n"
    "In the skinning algorithm, all transformations are done relative to the bind-pose. This relative transform is\n"
    "usually pre-computed for each node in the skeleton and is stored as a skinning matrix.\n"
    "To derive the new (skinned) position of a vertex, the skinning matrix of each influencing node transforms\n"
    "the bind-shape position of the vertex and the result is averaged using the blending weights.\n"
    "The easiest way to derive the skinning matrix is to multiply the current local-to-world matrix of a node by\n"
    "the inverse of the node's bind-matrix. This effectively cancels out the bind-pose transform of each node\n"
    "and allows us to work in the common object space of the skin.\n"
    "<br>\n"
    "The binding process usually involves:\n"
    "- Storing the current shape of the skin as the bind-shape\n"
    "- Computing and storing the bind-matrices\n"
    "\n"
    "Generating default blending weights, usually with some fall-off function: the farther a joint is from a\n"
    "given vertex, the less it influences it. Also, if a weight is 0, the influence can be omitted.\n"
    "After that, the artist is allowed to hand-modify the weights, usually by painting them on the mesh.\n"
    );

//! SkeletonBlendedGeometry Produced Events

EventDescription *SkeletonBlendedGeometryBase::_eventDesc[] =
{
    new EventDescription("SkeletonChanged", 
                          "",
                          SkeletonChangedEventId, 
                          FieldTraits<SkeletonEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&SkeletonBlendedGeometryBase::getHandleSkeletonChangedSignal))

};

EventProducerType SkeletonBlendedGeometryBase::_producerType(
    "SkeletonBlendedGeometryProducerType",
    "EventProducerType",
    "",
    InitEventProducerFunctor(),
    _eventDesc,
    sizeof(_eventDesc));

/*------------------------------ get -----------------------------------*/

FieldContainerType &SkeletonBlendedGeometryBase::getType(void)
{
    return _type;
}

const FieldContainerType &SkeletonBlendedGeometryBase::getType(void) const
{
    return _type;
}

const EventProducerType &SkeletonBlendedGeometryBase::getProducerType(void) const
{
    return _producerType;
}

UInt32 SkeletonBlendedGeometryBase::getContainerSize(void) const
{
    return sizeof(SkeletonBlendedGeometry);
}

/*------------------------- decorator get ------------------------------*/


//! Get the SkeletonBlendedGeometry::_sfBaseGeometry field.
const SFUnrecGeometryPtr *SkeletonBlendedGeometryBase::getSFBaseGeometry(void) const
{
    return &_sfBaseGeometry;
}

SFUnrecGeometryPtr  *SkeletonBlendedGeometryBase::editSFBaseGeometry   (void)
{
    editSField(BaseGeometryFieldMask);

    return &_sfBaseGeometry;
}

//! Get the SkeletonBlendedGeometry::_sfInternalWeightIndexes field.
const SFUnrecChildGeoIntegralPropertyPtr *SkeletonBlendedGeometryBase::getSFInternalWeightIndexes(void) const
{
    return &_sfInternalWeightIndexes;
}

SFUnrecChildGeoIntegralPropertyPtr *SkeletonBlendedGeometryBase::editSFInternalWeightIndexes(void)
{
    editSField(InternalWeightIndexesFieldMask);

    return &_sfInternalWeightIndexes;
}

//! Get the SkeletonBlendedGeometry::_sfInternalWeights field.
const SFUnrecChildGeoVectorPropertyPtr *SkeletonBlendedGeometryBase::getSFInternalWeights(void) const
{
    return &_sfInternalWeights;
}

SFUnrecChildGeoVectorPropertyPtr *SkeletonBlendedGeometryBase::editSFInternalWeights(void)
{
    editSField(InternalWeightsFieldMask);

    return &_sfInternalWeights;
}

//! Get the SkeletonBlendedGeometry::_mfInternalJoints field.
const MFUnrecNodePtr *SkeletonBlendedGeometryBase::getMFInternalJoints(void) const
{
    return &_mfInternalJoints;
}

MFUnrecNodePtr      *SkeletonBlendedGeometryBase::editMFInternalJoints (void)
{
    editMField(InternalJointsFieldMask, _mfInternalJoints);

    return &_mfInternalJoints;
}

MFMatrix *SkeletonBlendedGeometryBase::editMFInternalJointInvBindTransformations(void)
{
    editMField(InternalJointInvBindTransformationsFieldMask, _mfInternalJointInvBindTransformations);

    return &_mfInternalJointInvBindTransformations;
}

const MFMatrix *SkeletonBlendedGeometryBase::getMFInternalJointInvBindTransformations(void) const
{
    return &_mfInternalJointInvBindTransformations;
}


SFMatrix *SkeletonBlendedGeometryBase::editSFBindTransformation(void)
{
    editSField(BindTransformationFieldMask);

    return &_sfBindTransformation;
}

const SFMatrix *SkeletonBlendedGeometryBase::getSFBindTransformation(void) const
{
    return &_sfBindTransformation;
}




void SkeletonBlendedGeometryBase::pushToInternalJoints(Node * const value)
{
    editMField(InternalJointsFieldMask, _mfInternalJoints);

    _mfInternalJoints.push_back(value);
}

void SkeletonBlendedGeometryBase::assignInternalJoints(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<SkeletonBlendedGeometry *>(this)->clearInternalJoints();

    while(elemIt != elemEnd)
    {
        this->pushToInternalJoints(*elemIt);

        ++elemIt;
    }
}

void SkeletonBlendedGeometryBase::removeFromInternalJoints(UInt32 uiIndex)
{
    if(uiIndex < _mfInternalJoints.size())
    {
        editMField(InternalJointsFieldMask, _mfInternalJoints);

        _mfInternalJoints.erase(uiIndex);
    }
}

void SkeletonBlendedGeometryBase::removeObjFromInternalJoints(Node * const value)
{
    Int32 iElemIdx = _mfInternalJoints.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(InternalJointsFieldMask, _mfInternalJoints);

        _mfInternalJoints.erase(iElemIdx);
    }
}
void SkeletonBlendedGeometryBase::clearInternalJoints(void)
{
    editMField(InternalJointsFieldMask, _mfInternalJoints);


    _mfInternalJoints.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 SkeletonBlendedGeometryBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (BaseGeometryFieldMask & whichField))
    {
        returnValue += _sfBaseGeometry.getBinSize();
    }
    if(FieldBits::NoField != (InternalWeightIndexesFieldMask & whichField))
    {
        returnValue += _sfInternalWeightIndexes.getBinSize();
    }
    if(FieldBits::NoField != (InternalWeightsFieldMask & whichField))
    {
        returnValue += _sfInternalWeights.getBinSize();
    }
    if(FieldBits::NoField != (InternalJointsFieldMask & whichField))
    {
        returnValue += _mfInternalJoints.getBinSize();
    }
    if(FieldBits::NoField != (InternalJointInvBindTransformationsFieldMask & whichField))
    {
        returnValue += _mfInternalJointInvBindTransformations.getBinSize();
    }
    if(FieldBits::NoField != (BindTransformationFieldMask & whichField))
    {
        returnValue += _sfBindTransformation.getBinSize();
    }

    return returnValue;
}

void SkeletonBlendedGeometryBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (BaseGeometryFieldMask & whichField))
    {
        _sfBaseGeometry.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalWeightIndexesFieldMask & whichField))
    {
        _sfInternalWeightIndexes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalWeightsFieldMask & whichField))
    {
        _sfInternalWeights.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalJointsFieldMask & whichField))
    {
        _mfInternalJoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalJointInvBindTransformationsFieldMask & whichField))
    {
        _mfInternalJointInvBindTransformations.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BindTransformationFieldMask & whichField))
    {
        _sfBindTransformation.copyToBin(pMem);
    }
}

void SkeletonBlendedGeometryBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (BaseGeometryFieldMask & whichField))
    {
        editSField(BaseGeometryFieldMask);
        _sfBaseGeometry.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalWeightIndexesFieldMask & whichField))
    {
        editSField(InternalWeightIndexesFieldMask);
        _sfInternalWeightIndexes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalWeightsFieldMask & whichField))
    {
        editSField(InternalWeightsFieldMask);
        _sfInternalWeights.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalJointsFieldMask & whichField))
    {
        editMField(InternalJointsFieldMask, _mfInternalJoints);
        _mfInternalJoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalJointInvBindTransformationsFieldMask & whichField))
    {
        editMField(InternalJointInvBindTransformationsFieldMask, _mfInternalJointInvBindTransformations);
        _mfInternalJointInvBindTransformations.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BindTransformationFieldMask & whichField))
    {
        editSField(BindTransformationFieldMask);
        _sfBindTransformation.copyFromBin(pMem);
    }
}

//! create a new instance of the class
SkeletonBlendedGeometryTransitPtr SkeletonBlendedGeometryBase::createLocal(BitVector bFlags)
{
    SkeletonBlendedGeometryTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<SkeletonBlendedGeometry>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
SkeletonBlendedGeometryTransitPtr SkeletonBlendedGeometryBase::createDependent(BitVector bFlags)
{
    SkeletonBlendedGeometryTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<SkeletonBlendedGeometry>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
SkeletonBlendedGeometryTransitPtr SkeletonBlendedGeometryBase::create(void)
{
    SkeletonBlendedGeometryTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<SkeletonBlendedGeometry>(tmpPtr);
    }

    return fc;
}

SkeletonBlendedGeometry *SkeletonBlendedGeometryBase::createEmptyLocal(BitVector bFlags)
{
    SkeletonBlendedGeometry *returnValue;

    newPtr<SkeletonBlendedGeometry>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
SkeletonBlendedGeometry *SkeletonBlendedGeometryBase::createEmpty(void)
{
    SkeletonBlendedGeometry *returnValue;

    newPtr<SkeletonBlendedGeometry>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}

FieldContainerTransitPtr SkeletonBlendedGeometryBase::shallowCopyLocal(
    BitVector bFlags) const
{
    SkeletonBlendedGeometry *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const SkeletonBlendedGeometry *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr SkeletonBlendedGeometryBase::shallowCopyDependent(
    BitVector bFlags) const
{
    SkeletonBlendedGeometry *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const SkeletonBlendedGeometry *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr SkeletonBlendedGeometryBase::shallowCopy(void) const
{
    SkeletonBlendedGeometry *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const SkeletonBlendedGeometry *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}



/*------------------------- event producers ----------------------------------*/
void SkeletonBlendedGeometryBase::produceEvent(UInt32 eventId, EventDetails* const e)
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        OSG_ASSERT(dynamic_cast<SkeletonChangedEventDetailsType* const>(e));

        _SkeletonChangedEvent.set_combiner(ConsumableEventCombiner(e));
        _SkeletonChangedEvent(dynamic_cast<SkeletonChangedEventDetailsType* const>(e), SkeletonChangedEventId);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        break;
    }
}

boost::signals2::connection SkeletonBlendedGeometryBase::connectEvent(UInt32 eventId, 
                                                             const BaseEventType::slot_type &listener, 
                                                             boost::signals2::connect_position at)
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        return _SkeletonChangedEvent.connect(listener, at);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return boost::signals2::connection();
        break;
    }

    return boost::signals2::connection();
}

boost::signals2::connection  SkeletonBlendedGeometryBase::connectEvent(UInt32 eventId, 
                                                              const BaseEventType::group_type &group,
                                                              const BaseEventType::slot_type &listener,
                                                              boost::signals2::connect_position at)
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        return _SkeletonChangedEvent.connect(group, listener, at);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return boost::signals2::connection();
        break;
    }

    return boost::signals2::connection();
}
    
void  SkeletonBlendedGeometryBase::disconnectEvent(UInt32 eventId, const BaseEventType::group_type &group)
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        _SkeletonChangedEvent.disconnect(group);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        break;
    }
}

void  SkeletonBlendedGeometryBase::disconnectAllSlotsEvent(UInt32 eventId)
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        _SkeletonChangedEvent.disconnect_all_slots();
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        break;
    }
}

bool  SkeletonBlendedGeometryBase::isEmptyEvent(UInt32 eventId) const
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        return _SkeletonChangedEvent.empty();
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return true;
        break;
    }
}

UInt32  SkeletonBlendedGeometryBase::numSlotsEvent(UInt32 eventId) const
{
    switch(eventId)
    {
    case SkeletonChangedEventId:
        return _SkeletonChangedEvent.num_slots();
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return 0;
        break;
    }
}


/*------------------------- constructors ----------------------------------*/

SkeletonBlendedGeometryBase::SkeletonBlendedGeometryBase(void) :
    Inherited(),
    _sfBaseGeometry           (NULL),
    _sfInternalWeightIndexes  (this,
                          InternalWeightIndexesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfInternalWeights        (this,
                          InternalWeightsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfInternalJoints         (),
    _mfInternalJointInvBindTransformations(),
    _sfBindTransformation     ()
{
}

SkeletonBlendedGeometryBase::SkeletonBlendedGeometryBase(const SkeletonBlendedGeometryBase &source) :
    Inherited(source),
    _sfBaseGeometry           (NULL),
    _sfInternalWeightIndexes  (this,
                          InternalWeightIndexesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfInternalWeights        (this,
                          InternalWeightsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfInternalJoints         (),
    _mfInternalJointInvBindTransformations(source._mfInternalJointInvBindTransformations),
    _sfBindTransformation     (source._sfBindTransformation     )
{
}


/*-------------------------- destructors ----------------------------------*/

SkeletonBlendedGeometryBase::~SkeletonBlendedGeometryBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool SkeletonBlendedGeometryBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == InternalWeightIndexesFieldId)
    {
        GeoIntegralProperty * pTypedChild =
            dynamic_cast<GeoIntegralProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfInternalWeightIndexes.getValue() == pTypedChild)
            {
                editSField(InternalWeightIndexesFieldMask);

                _sfInternalWeightIndexes.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }

    if(childFieldId == InternalWeightsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfInternalWeights.getValue() == pTypedChild)
            {
                editSField(InternalWeightsFieldMask);

                _sfInternalWeights.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void SkeletonBlendedGeometryBase::onCreate(const SkeletonBlendedGeometry *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        SkeletonBlendedGeometry *pThis = static_cast<SkeletonBlendedGeometry *>(this);

        pThis->setBaseGeometry(source->getBaseGeometry());

        pThis->setInternalWeightIndexes(source->getInternalWeightIndexes());

        pThis->setInternalWeights(source->getInternalWeights());

        MFUnrecNodePtr::const_iterator InternalJointsIt  =
            source->_mfInternalJoints.begin();
        MFUnrecNodePtr::const_iterator InternalJointsEnd =
            source->_mfInternalJoints.end  ();

        while(InternalJointsIt != InternalJointsEnd)
        {
            pThis->pushToInternalJoints(*InternalJointsIt);

            ++InternalJointsIt;
        }
    }
}

GetFieldHandlePtr SkeletonBlendedGeometryBase::getHandleBaseGeometry    (void) const
{
    SFUnrecGeometryPtr::GetHandlePtr returnValue(
        new  SFUnrecGeometryPtr::GetHandle(
             &_sfBaseGeometry,
             this->getType().getFieldDesc(BaseGeometryFieldId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBlendedGeometryBase::editHandleBaseGeometry   (void)
{
    SFUnrecGeometryPtr::EditHandlePtr returnValue(
        new  SFUnrecGeometryPtr::EditHandle(
             &_sfBaseGeometry,
             this->getType().getFieldDesc(BaseGeometryFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&SkeletonBlendedGeometry::setBaseGeometry,
                    static_cast<SkeletonBlendedGeometry *>(this), _1));

    editSField(BaseGeometryFieldMask);

    return returnValue;
}

GetFieldHandlePtr SkeletonBlendedGeometryBase::getHandleInternalWeightIndexes (void) const
{
    SFUnrecChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoIntegralPropertyPtr::GetHandle(
             &_sfInternalWeightIndexes,
             this->getType().getFieldDesc(InternalWeightIndexesFieldId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBlendedGeometryBase::editHandleInternalWeightIndexes(void)
{
    SFUnrecChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoIntegralPropertyPtr::EditHandle(
             &_sfInternalWeightIndexes,
             this->getType().getFieldDesc(InternalWeightIndexesFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&SkeletonBlendedGeometry::setInternalWeightIndexes,
                    static_cast<SkeletonBlendedGeometry *>(this), _1));

    editSField(InternalWeightIndexesFieldMask);

    return returnValue;
}

GetFieldHandlePtr SkeletonBlendedGeometryBase::getHandleInternalWeights (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfInternalWeights,
             this->getType().getFieldDesc(InternalWeightsFieldId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBlendedGeometryBase::editHandleInternalWeights(void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfInternalWeights,
             this->getType().getFieldDesc(InternalWeightsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&SkeletonBlendedGeometry::setInternalWeights,
                    static_cast<SkeletonBlendedGeometry *>(this), _1));

    editSField(InternalWeightsFieldMask);

    return returnValue;
}

GetFieldHandlePtr SkeletonBlendedGeometryBase::getHandleInternalJoints  (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfInternalJoints,
             this->getType().getFieldDesc(InternalJointsFieldId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBlendedGeometryBase::editHandleInternalJoints (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfInternalJoints,
             this->getType().getFieldDesc(InternalJointsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&SkeletonBlendedGeometry::pushToInternalJoints,
                    static_cast<SkeletonBlendedGeometry *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&SkeletonBlendedGeometry::removeFromInternalJoints,
                    static_cast<SkeletonBlendedGeometry *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&SkeletonBlendedGeometry::removeObjFromInternalJoints,
                    static_cast<SkeletonBlendedGeometry *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&SkeletonBlendedGeometry::clearInternalJoints,
                    static_cast<SkeletonBlendedGeometry *>(this)));

    editMField(InternalJointsFieldMask, _mfInternalJoints);

    return returnValue;
}

GetFieldHandlePtr SkeletonBlendedGeometryBase::getHandleInternalJointInvBindTransformations (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfInternalJointInvBindTransformations,
             this->getType().getFieldDesc(InternalJointInvBindTransformationsFieldId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBlendedGeometryBase::editHandleInternalJointInvBindTransformations(void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfInternalJointInvBindTransformations,
             this->getType().getFieldDesc(InternalJointInvBindTransformationsFieldId),
             this));


    editMField(InternalJointInvBindTransformationsFieldMask, _mfInternalJointInvBindTransformations);

    return returnValue;
}

GetFieldHandlePtr SkeletonBlendedGeometryBase::getHandleBindTransformation (void) const
{
    SFMatrix::GetHandlePtr returnValue(
        new  SFMatrix::GetHandle(
             &_sfBindTransformation,
             this->getType().getFieldDesc(BindTransformationFieldId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBlendedGeometryBase::editHandleBindTransformation(void)
{
    SFMatrix::EditHandlePtr returnValue(
        new  SFMatrix::EditHandle(
             &_sfBindTransformation,
             this->getType().getFieldDesc(BindTransformationFieldId),
             this));


    editSField(BindTransformationFieldMask);

    return returnValue;
}


GetEventHandlePtr SkeletonBlendedGeometryBase::getHandleSkeletonChangedSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<SkeletonChangedEventType>(
             const_cast<SkeletonChangedEventType *>(&_SkeletonChangedEvent),
             _producerType.getEventDescription(SkeletonChangedEventId),
             const_cast<SkeletonBlendedGeometryBase *>(this)));

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void SkeletonBlendedGeometryBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    SkeletonBlendedGeometry *pThis = static_cast<SkeletonBlendedGeometry *>(this);

    pThis->execSync(static_cast<SkeletonBlendedGeometry *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *SkeletonBlendedGeometryBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    SkeletonBlendedGeometry *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const SkeletonBlendedGeometry *>(pRefAspect),
                  dynamic_cast<const SkeletonBlendedGeometry *>(this));

    return returnValue;
}
#endif

void SkeletonBlendedGeometryBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<SkeletonBlendedGeometry *>(this)->setBaseGeometry(NULL);

    static_cast<SkeletonBlendedGeometry *>(this)->setInternalWeightIndexes(NULL);

    static_cast<SkeletonBlendedGeometry *>(this)->setInternalWeights(NULL);

    static_cast<SkeletonBlendedGeometry *>(this)->clearInternalJoints();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfInternalJointInvBindTransformations.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
