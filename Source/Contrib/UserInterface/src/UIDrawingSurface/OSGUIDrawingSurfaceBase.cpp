/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: David Kabala (djkabala@gmail.com)                                *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class UIDrawingSurface!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"



#include "OSGInternalWindow.h"          // InternalWindows Class
#include "OSGWindowEventProducer.h"     // EventProducer Class
#include "OSGGraphics.h"                // Graphics Class
#include "OSGUIDrawingSurfaceMouseTransformFunctor.h" // MouseTransformFunctor Class

#include "OSGUIDrawingSurfaceBase.h"
#include "OSGUIDrawingSurface.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::UIDrawingSurface
    A virtual surface that a graphical user interface is drawn on.
    The drawing surface manages a set of OSG::InternalWindows.  The 
    UIDrawingSurface must be attached to an event producer to pass
    mouse, key, and update events to the OSG::InternalWindows it contains.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var InternalWindow * UIDrawingSurfaceBase::_mfInternalWindows
    The windows of the drawing surface.
*/

/*! \var InternalWindow * UIDrawingSurfaceBase::_sfFocusedWindow
    The window that has focus
*/

/*! \var WindowEventProducer * UIDrawingSurfaceBase::_sfEventProducer
    The event producer used by this DrawingSurface.  The event producer must 
    produce mouse, key, and update events.  These events are processed and passed
    to the windows of this drawing surface.
*/

/*! \var Graphics *      UIDrawingSurfaceBase::_sfGraphics
    The OSG::Graphics object used for drawing.
*/

/*! \var UIDrawingSurfaceMouseTransformFunctor * UIDrawingSurfaceBase::_sfMouseTransformFunctor
    A functor object used for transforming the mouse coordinates.
    This is used by OSG::UIForeground and OSG::UIRectangle for transforming
    the mouse coordinates when the DrawingSurface is connected to them.
*/

/*! \var Vec2f           UIDrawingSurfaceBase::_sfSize
    The size of the DrawingSurface.
*/

/*! \var bool            UIDrawingSurfaceBase::_sfActive
    Controls whether this DrawingSurface responds to events.  If Active is false
    then no mouse, key, or update events are processed.
*/

/*! \var FieldContainerMap UIDrawingSurfaceBase::_sfCursors
    A map of the cursors for the DrawingSurface.  The UIDrawinSurface will query the 
    WindowEventProducer it is attached to for the the current cursor type.  This is 
    used as the key for this Cursor map.  If there is no value for the given key, then
    no cursor is drawn.
*/

/*! \var Pnt2f           UIDrawingSurfaceBase::_sfCursorPosition
    The position of the cursor.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<UIDrawingSurface *>::_type("UIDrawingSurfacePtr", "AttachmentContainerPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(UIDrawingSurface *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           UIDrawingSurface *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           UIDrawingSurface *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void UIDrawingSurfaceBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFUnrecChildInternalWindowPtr::Description(
        MFUnrecChildInternalWindowPtr::getClassType(),
        "InternalWindows",
        "The windows of the drawing surface.\n",
        InternalWindowsFieldId, InternalWindowsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FNullCheckAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleInternalWindows),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleInternalWindows));

    oType.addInitialDesc(pDesc);

    pDesc = new SFWeakInternalWindowPtr::Description(
        SFWeakInternalWindowPtr::getClassType(),
        "FocusedWindow",
        "The window that has focus\n",
        FocusedWindowFieldId, FocusedWindowFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleFocusedWindow),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleFocusedWindow));

    oType.addInitialDesc(pDesc);

    pDesc = new SFWeakWindowEventProducerPtr::Description(
        SFWeakWindowEventProducerPtr::getClassType(),
        "EventProducer",
        "The event producer used by this DrawingSurface.  The event producer must \n"
        "produce mouse, key, and update events.  These events are processed and passed\n"
        "to the windows of this drawing surface.\n",
        EventProducerFieldId, EventProducerFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleEventProducer),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleEventProducer));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecGraphicsPtr::Description(
        SFUnrecGraphicsPtr::getClassType(),
        "Graphics",
        "The OSG::Graphics object used for drawing.\n",
        GraphicsFieldId, GraphicsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleGraphics),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleGraphics));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr::Description(
        SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr::getClassType(),
        "MouseTransformFunctor",
        "A functor object used for transforming the mouse coordinates.\n"
        "This is used by OSG::UIForeground and OSG::UIRectangle for transforming\n"
        "the mouse coordinates when the DrawingSurface is connected to them.\n",
        MouseTransformFunctorFieldId, MouseTransformFunctorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleMouseTransformFunctor),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleMouseTransformFunctor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec2f::Description(
        SFVec2f::getClassType(),
        "Size",
        "The size of the DrawingSurface.\n",
        SizeFieldId, SizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleSize),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "Active",
        "Controls whether this DrawingSurface responds to events.  If Active is false\n"
        "then no mouse, key, or update events are processed.\n",
        ActiveFieldId, ActiveFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleActive),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleActive));

    oType.addInitialDesc(pDesc);

    pDesc = new SFFieldContainerMap::Description(
        SFFieldContainerMap::getClassType(),
        "Cursors",
        "A map of the cursors for the DrawingSurface.  The UIDrawinSurface will query the \n"
        "WindowEventProducer it is attached to for the the current cursor type.  This is \n"
        "used as the key for this Cursor map.  If there is no value for the given key, then\n"
        "no cursor is drawn.\n",
        CursorsFieldId, CursorsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleCursors),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleCursors));

    oType.addInitialDesc(pDesc);

    pDesc = new SFPnt2f::Description(
        SFPnt2f::getClassType(),
        "CursorPosition",
        "The position of the cursor.\n",
        CursorPositionFieldId, CursorPositionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&UIDrawingSurface::editHandleCursorPosition),
        static_cast<FieldGetMethodSig >(&UIDrawingSurface::getHandleCursorPosition));

    oType.addInitialDesc(pDesc);
}


UIDrawingSurfaceBase::TypeObject UIDrawingSurfaceBase::_type(
    UIDrawingSurfaceBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&UIDrawingSurfaceBase::createEmptyLocal),
    UIDrawingSurface::initMethod,
    UIDrawingSurface::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&UIDrawingSurface::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"UIDrawingSurface\"\n"
    "    parent=\"AttachmentContainer\"\n"
    "    library=\"ContribUserInterface\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    authors=\"David Kabala (djkabala@gmail.com)\"\n"
    "    >\n"
    "    A virtual surface that a graphical user interface is drawn on.\n"
    "    The drawing surface manages a set of OSG::InternalWindows.  The \n"
    "    UIDrawingSurface must be attached to an event producer to pass\n"
    "    mouse, key, and update events to the OSG::InternalWindows it contains.\n"
    "    <Field\n"
    "        name=\"InternalWindows\"\n"
    "        type=\"InternalWindow\"\n"
    "        cardinality=\"multi\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        ptrFieldAccess = \"nullCheck\"\n"
    "        linkParentField=\"ParentDrawingSurface\"\n"
    "        >\n"
    "        The windows of the drawing surface.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"FocusedWindow\"\n"
    "        type=\"InternalWindow\"\n"
    "        category=\"weakpointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The window that has focus\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"EventProducer\"\n"
    "        type=\"WindowEventProducer\"\n"
    "        category=\"weakpointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The event producer used by this DrawingSurface.  The event producer must \n"
    "        produce mouse, key, and update events.  These events are processed and passed\n"
    "        to the windows of this drawing surface.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Graphics\"\n"
    "        type=\"Graphics\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The OSG::Graphics object used for drawing.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"MouseTransformFunctor\"\n"
    "        type=\"UIDrawingSurfaceMouseTransformFunctor\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        A functor object used for transforming the mouse coordinates.\n"
    "        This is used by OSG::UIForeground and OSG::UIRectangle for transforming\n"
    "        the mouse coordinates when the DrawingSurface is connected to them.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Size\"\n"
    "        type=\"Vec2f\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.0f,0.0f\"\n"
    "        >\n"
    "        The size of the DrawingSurface.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Active\"\n"
    "        type=\"bool\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "        >\n"
    "        Controls whether this DrawingSurface responds to events.  If Active is false\n"
    "        then no mouse, key, or update events are processed.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Cursors\"\n"
    "        type=\"FieldContainerMap\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        >\n"
    "        A map of the cursors for the DrawingSurface.  The UIDrawinSurface will query the \n"
    "        WindowEventProducer it is attached to for the the current cursor type.  This is \n"
    "        used as the key for this Cursor map.  If there is no value for the given key, then\n"
    "        no cursor is drawn.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"CursorPosition\"\n"
    "        type=\"Pnt2f\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0.0f,0.0f\"\n"
    "        >\n"
    "        The position of the cursor.\n"
    "    </Field>\n"
    "</FieldContainer>\n",
    "A virtual surface that a graphical user interface is drawn on.\n"
    "The drawing surface manages a set of OSG::InternalWindows.  The \n"
    "UIDrawingSurface must be attached to an event producer to pass\n"
    "mouse, key, and update events to the OSG::InternalWindows it contains.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &UIDrawingSurfaceBase::getType(void)
{
    return _type;
}

const FieldContainerType &UIDrawingSurfaceBase::getType(void) const
{
    return _type;
}

UInt32 UIDrawingSurfaceBase::getContainerSize(void) const
{
    return sizeof(UIDrawingSurface);
}

/*------------------------- decorator get ------------------------------*/


//! Get the UIDrawingSurface::_mfInternalWindows field.
const MFUnrecChildInternalWindowPtr *UIDrawingSurfaceBase::getMFInternalWindows(void) const
{
    return &_mfInternalWindows;
}

//! Get the UIDrawingSurface::_sfFocusedWindow field.
const SFWeakInternalWindowPtr *UIDrawingSurfaceBase::getSFFocusedWindow(void) const
{
    return &_sfFocusedWindow;
}

SFWeakInternalWindowPtr *UIDrawingSurfaceBase::editSFFocusedWindow  (void)
{
    editSField(FocusedWindowFieldMask);

    return &_sfFocusedWindow;
}

//! Get the UIDrawingSurface::_sfEventProducer field.
const SFWeakWindowEventProducerPtr *UIDrawingSurfaceBase::getSFEventProducer(void) const
{
    return &_sfEventProducer;
}

SFWeakWindowEventProducerPtr *UIDrawingSurfaceBase::editSFEventProducer  (void)
{
    editSField(EventProducerFieldMask);

    return &_sfEventProducer;
}

//! Get the UIDrawingSurface::_sfGraphics field.
const SFUnrecGraphicsPtr *UIDrawingSurfaceBase::getSFGraphics(void) const
{
    return &_sfGraphics;
}

SFUnrecGraphicsPtr  *UIDrawingSurfaceBase::editSFGraphics       (void)
{
    editSField(GraphicsFieldMask);

    return &_sfGraphics;
}

//! Get the UIDrawingSurface::_sfMouseTransformFunctor field.
const SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr *UIDrawingSurfaceBase::getSFMouseTransformFunctor(void) const
{
    return &_sfMouseTransformFunctor;
}

SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr *UIDrawingSurfaceBase::editSFMouseTransformFunctor(void)
{
    editSField(MouseTransformFunctorFieldMask);

    return &_sfMouseTransformFunctor;
}

SFVec2f *UIDrawingSurfaceBase::editSFSize(void)
{
    editSField(SizeFieldMask);

    return &_sfSize;
}

const SFVec2f *UIDrawingSurfaceBase::getSFSize(void) const
{
    return &_sfSize;
}


SFBool *UIDrawingSurfaceBase::editSFActive(void)
{
    editSField(ActiveFieldMask);

    return &_sfActive;
}

const SFBool *UIDrawingSurfaceBase::getSFActive(void) const
{
    return &_sfActive;
}


SFFieldContainerMap *UIDrawingSurfaceBase::editSFCursors(void)
{
    editSField(CursorsFieldMask);

    return &_sfCursors;
}

const SFFieldContainerMap *UIDrawingSurfaceBase::getSFCursors(void) const
{
    return &_sfCursors;
}


SFPnt2f *UIDrawingSurfaceBase::editSFCursorPosition(void)
{
    editSField(CursorPositionFieldMask);

    return &_sfCursorPosition;
}

const SFPnt2f *UIDrawingSurfaceBase::getSFCursorPosition(void) const
{
    return &_sfCursorPosition;
}




void UIDrawingSurfaceBase::pushToInternalWindows(InternalWindow * const value)
{
    if(value == NULL)
        return;

    editMField(InternalWindowsFieldMask, _mfInternalWindows);

    _mfInternalWindows.push_back(value);
}

void UIDrawingSurfaceBase::assignInternalWindows(const MFUnrecChildInternalWindowPtr &value)
{
    MFUnrecChildInternalWindowPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecChildInternalWindowPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<UIDrawingSurface *>(this)->clearInternalWindows();

    while(elemIt != elemEnd)
    {
        this->pushToInternalWindows(*elemIt);

        ++elemIt;
    }
}

void UIDrawingSurfaceBase::insertIntoInternalWindows(UInt32               uiIndex,
                                                   InternalWindow * const value   )
{
    if(value == NULL)
        return;

    editMField(InternalWindowsFieldMask, _mfInternalWindows);

    MFUnrecChildInternalWindowPtr::iterator fieldIt = _mfInternalWindows.begin_nc();

    fieldIt += uiIndex;

    _mfInternalWindows.insert(fieldIt, value);
}

void UIDrawingSurfaceBase::replaceInInternalWindows(UInt32               uiIndex,
                                                       InternalWindow * const value   )
{
    if(value == NULL)
        return;

    if(uiIndex >= _mfInternalWindows.size())
        return;

    editMField(InternalWindowsFieldMask, _mfInternalWindows);

    _mfInternalWindows.replace(uiIndex, value);
}

void UIDrawingSurfaceBase::replaceObjInInternalWindows(InternalWindow * const pOldElem,
                                                        InternalWindow * const pNewElem)
{
    if(pNewElem == NULL)
        return;

    Int32  elemIdx = _mfInternalWindows.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(InternalWindowsFieldMask, _mfInternalWindows);

        _mfInternalWindows.replace(elemIdx, pNewElem);
    }
}

void UIDrawingSurfaceBase::removeFromInternalWindows(UInt32 uiIndex)
{
    if(uiIndex < _mfInternalWindows.size())
    {
        editMField(InternalWindowsFieldMask, _mfInternalWindows);

        _mfInternalWindows.erase(uiIndex);
    }
}

void UIDrawingSurfaceBase::removeObjFromInternalWindows(InternalWindow * const value)
{
    Int32 iElemIdx = _mfInternalWindows.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(InternalWindowsFieldMask, _mfInternalWindows);

        _mfInternalWindows.erase(iElemIdx);
    }
}
void UIDrawingSurfaceBase::clearInternalWindows(void)
{
    editMField(InternalWindowsFieldMask, _mfInternalWindows);


    _mfInternalWindows.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 UIDrawingSurfaceBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (InternalWindowsFieldMask & whichField))
    {
        returnValue += _mfInternalWindows.getBinSize();
    }
    if(FieldBits::NoField != (FocusedWindowFieldMask & whichField))
    {
        returnValue += _sfFocusedWindow.getBinSize();
    }
    if(FieldBits::NoField != (EventProducerFieldMask & whichField))
    {
        returnValue += _sfEventProducer.getBinSize();
    }
    if(FieldBits::NoField != (GraphicsFieldMask & whichField))
    {
        returnValue += _sfGraphics.getBinSize();
    }
    if(FieldBits::NoField != (MouseTransformFunctorFieldMask & whichField))
    {
        returnValue += _sfMouseTransformFunctor.getBinSize();
    }
    if(FieldBits::NoField != (SizeFieldMask & whichField))
    {
        returnValue += _sfSize.getBinSize();
    }
    if(FieldBits::NoField != (ActiveFieldMask & whichField))
    {
        returnValue += _sfActive.getBinSize();
    }
    if(FieldBits::NoField != (CursorsFieldMask & whichField))
    {
        returnValue += _sfCursors.getBinSize();
    }
    if(FieldBits::NoField != (CursorPositionFieldMask & whichField))
    {
        returnValue += _sfCursorPosition.getBinSize();
    }

    return returnValue;
}

void UIDrawingSurfaceBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (InternalWindowsFieldMask & whichField))
    {
        _mfInternalWindows.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FocusedWindowFieldMask & whichField))
    {
        _sfFocusedWindow.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EventProducerFieldMask & whichField))
    {
        _sfEventProducer.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GraphicsFieldMask & whichField))
    {
        _sfGraphics.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MouseTransformFunctorFieldMask & whichField))
    {
        _sfMouseTransformFunctor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SizeFieldMask & whichField))
    {
        _sfSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ActiveFieldMask & whichField))
    {
        _sfActive.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CursorsFieldMask & whichField))
    {
        _sfCursors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CursorPositionFieldMask & whichField))
    {
        _sfCursorPosition.copyToBin(pMem);
    }
}

void UIDrawingSurfaceBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (InternalWindowsFieldMask & whichField))
    {
        editMField(InternalWindowsFieldMask, _mfInternalWindows);
        _mfInternalWindows.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FocusedWindowFieldMask & whichField))
    {
        editSField(FocusedWindowFieldMask);
        _sfFocusedWindow.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EventProducerFieldMask & whichField))
    {
        editSField(EventProducerFieldMask);
        _sfEventProducer.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GraphicsFieldMask & whichField))
    {
        editSField(GraphicsFieldMask);
        _sfGraphics.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MouseTransformFunctorFieldMask & whichField))
    {
        editSField(MouseTransformFunctorFieldMask);
        _sfMouseTransformFunctor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SizeFieldMask & whichField))
    {
        editSField(SizeFieldMask);
        _sfSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ActiveFieldMask & whichField))
    {
        editSField(ActiveFieldMask);
        _sfActive.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CursorsFieldMask & whichField))
    {
        editSField(CursorsFieldMask);
        _sfCursors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CursorPositionFieldMask & whichField))
    {
        editSField(CursorPositionFieldMask);
        _sfCursorPosition.copyFromBin(pMem);
    }
}

//! create a new instance of the class
UIDrawingSurfaceTransitPtr UIDrawingSurfaceBase::createLocal(BitVector bFlags)
{
    UIDrawingSurfaceTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<UIDrawingSurface>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
UIDrawingSurfaceTransitPtr UIDrawingSurfaceBase::createDependent(BitVector bFlags)
{
    UIDrawingSurfaceTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<UIDrawingSurface>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
UIDrawingSurfaceTransitPtr UIDrawingSurfaceBase::create(void)
{
    UIDrawingSurfaceTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<UIDrawingSurface>(tmpPtr);
    }

    return fc;
}

UIDrawingSurface *UIDrawingSurfaceBase::createEmptyLocal(BitVector bFlags)
{
    UIDrawingSurface *returnValue;

    newPtr<UIDrawingSurface>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
UIDrawingSurface *UIDrawingSurfaceBase::createEmpty(void)
{
    UIDrawingSurface *returnValue;

    newPtr<UIDrawingSurface>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}

FieldContainerTransitPtr UIDrawingSurfaceBase::shallowCopyLocal(
    BitVector bFlags) const
{
    UIDrawingSurface *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const UIDrawingSurface *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr UIDrawingSurfaceBase::shallowCopyDependent(
    BitVector bFlags) const
{
    UIDrawingSurface *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const UIDrawingSurface *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr UIDrawingSurfaceBase::shallowCopy(void) const
{
    UIDrawingSurface *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const UIDrawingSurface *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

UIDrawingSurfaceBase::UIDrawingSurfaceBase(void) :
    Inherited(),
    _mfInternalWindows        (this,
                          InternalWindowsFieldId,
                          InternalWindow::ParentDrawingSurfaceFieldId),
    _sfFocusedWindow          (NULL),
    _sfEventProducer          (NULL),
    _sfGraphics               (NULL),
    _sfMouseTransformFunctor  (NULL),
    _sfSize                   (Vec2f(0.0f,0.0f)),
    _sfActive                 (bool(true)),
    _sfCursors                (),
    _sfCursorPosition         (Pnt2f(0.0f,0.0f))
{
}

UIDrawingSurfaceBase::UIDrawingSurfaceBase(const UIDrawingSurfaceBase &source) :
    Inherited(source),
    _mfInternalWindows        (this,
                          InternalWindowsFieldId,
                          InternalWindow::ParentDrawingSurfaceFieldId),
    _sfFocusedWindow          (NULL),
    _sfEventProducer          (NULL),
    _sfGraphics               (NULL),
    _sfMouseTransformFunctor  (NULL),
    _sfSize                   (source._sfSize                   ),
    _sfActive                 (source._sfActive                 ),
    _sfCursors                (source._sfCursors                ),
    _sfCursorPosition         (source._sfCursorPosition         )
{
}


/*-------------------------- destructors ----------------------------------*/

UIDrawingSurfaceBase::~UIDrawingSurfaceBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool UIDrawingSurfaceBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == InternalWindowsFieldId)
    {
        InternalWindow * pTypedChild =
            dynamic_cast<InternalWindow *>(pChild);

        if(pTypedChild != NULL)
        {
            Int32 iChildIdx = _mfInternalWindows.findIndex(pTypedChild);

            if(iChildIdx != -1)
            {
                editMField(InternalWindowsFieldMask, _mfInternalWindows);

                _mfInternalWindows.erase(iChildIdx);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void UIDrawingSurfaceBase::onCreate(const UIDrawingSurface *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        UIDrawingSurface *pThis = static_cast<UIDrawingSurface *>(this);

        MFUnrecChildInternalWindowPtr::const_iterator InternalWindowsIt  =
            source->_mfInternalWindows.begin();
        MFUnrecChildInternalWindowPtr::const_iterator InternalWindowsEnd =
            source->_mfInternalWindows.end  ();

        while(InternalWindowsIt != InternalWindowsEnd)
        {
            pThis->pushToInternalWindows(*InternalWindowsIt);

            ++InternalWindowsIt;
        }

        pThis->setFocusedWindow(source->getFocusedWindow());

        pThis->setEventProducer(source->getEventProducer());

        pThis->setGraphics(source->getGraphics());

        pThis->setMouseTransformFunctor(source->getMouseTransformFunctor());
    }
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleInternalWindows (void) const
{
    MFUnrecChildInternalWindowPtr::GetHandlePtr returnValue(
        new  MFUnrecChildInternalWindowPtr::GetHandle(
             &_mfInternalWindows,
             this->getType().getFieldDesc(InternalWindowsFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleInternalWindows(void)
{
    MFUnrecChildInternalWindowPtr::EditHandlePtr returnValue(
        new  MFUnrecChildInternalWindowPtr::EditHandle(
             &_mfInternalWindows,
             this->getType().getFieldDesc(InternalWindowsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&UIDrawingSurface::pushToInternalWindows,
                    static_cast<UIDrawingSurface *>(this), _1));
    returnValue->setInsertMethod(
        boost::bind(&UIDrawingSurface::insertIntoInternalWindows,
                    static_cast<UIDrawingSurface *>(this), _1, _2));
    returnValue->setReplaceMethod(
        boost::bind(&UIDrawingSurface::replaceInInternalWindows,
                    static_cast<UIDrawingSurface *>(this), _1, _2));
    returnValue->setReplaceObjMethod(
        boost::bind(&UIDrawingSurface::replaceObjInInternalWindows,
                    static_cast<UIDrawingSurface *>(this), _1, _2));
    returnValue->setRemoveMethod(
        boost::bind(&UIDrawingSurface::removeFromInternalWindows,
                    static_cast<UIDrawingSurface *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&UIDrawingSurface::removeObjFromInternalWindows,
                    static_cast<UIDrawingSurface *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&UIDrawingSurface::clearInternalWindows,
                    static_cast<UIDrawingSurface *>(this)));

    editMField(InternalWindowsFieldMask, _mfInternalWindows);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleFocusedWindow   (void) const
{
    SFWeakInternalWindowPtr::GetHandlePtr returnValue(
        new  SFWeakInternalWindowPtr::GetHandle(
             &_sfFocusedWindow,
             this->getType().getFieldDesc(FocusedWindowFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleFocusedWindow  (void)
{
    SFWeakInternalWindowPtr::EditHandlePtr returnValue(
        new  SFWeakInternalWindowPtr::EditHandle(
             &_sfFocusedWindow,
             this->getType().getFieldDesc(FocusedWindowFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&UIDrawingSurface::setFocusedWindow,
                    static_cast<UIDrawingSurface *>(this), _1));

    editSField(FocusedWindowFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleEventProducer   (void) const
{
    SFWeakWindowEventProducerPtr::GetHandlePtr returnValue(
        new  SFWeakWindowEventProducerPtr::GetHandle(
             &_sfEventProducer,
             this->getType().getFieldDesc(EventProducerFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleEventProducer  (void)
{
    SFWeakWindowEventProducerPtr::EditHandlePtr returnValue(
        new  SFWeakWindowEventProducerPtr::EditHandle(
             &_sfEventProducer,
             this->getType().getFieldDesc(EventProducerFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&UIDrawingSurface::setEventProducer,
                    static_cast<UIDrawingSurface *>(this), _1));

    editSField(EventProducerFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleGraphics        (void) const
{
    SFUnrecGraphicsPtr::GetHandlePtr returnValue(
        new  SFUnrecGraphicsPtr::GetHandle(
             &_sfGraphics,
             this->getType().getFieldDesc(GraphicsFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleGraphics       (void)
{
    SFUnrecGraphicsPtr::EditHandlePtr returnValue(
        new  SFUnrecGraphicsPtr::EditHandle(
             &_sfGraphics,
             this->getType().getFieldDesc(GraphicsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&UIDrawingSurface::setGraphics,
                    static_cast<UIDrawingSurface *>(this), _1));

    editSField(GraphicsFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleMouseTransformFunctor (void) const
{
    SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr::GetHandlePtr returnValue(
        new  SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr::GetHandle(
             &_sfMouseTransformFunctor,
             this->getType().getFieldDesc(MouseTransformFunctorFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleMouseTransformFunctor(void)
{
    SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr::EditHandlePtr returnValue(
        new  SFUnrecUIDrawingSurfaceMouseTransformFunctorPtr::EditHandle(
             &_sfMouseTransformFunctor,
             this->getType().getFieldDesc(MouseTransformFunctorFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&UIDrawingSurface::setMouseTransformFunctor,
                    static_cast<UIDrawingSurface *>(this), _1));

    editSField(MouseTransformFunctorFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleSize            (void) const
{
    SFVec2f::GetHandlePtr returnValue(
        new  SFVec2f::GetHandle(
             &_sfSize,
             this->getType().getFieldDesc(SizeFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleSize           (void)
{
    SFVec2f::EditHandlePtr returnValue(
        new  SFVec2f::EditHandle(
             &_sfSize,
             this->getType().getFieldDesc(SizeFieldId),
             this));


    editSField(SizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleActive          (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfActive,
             this->getType().getFieldDesc(ActiveFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleActive         (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfActive,
             this->getType().getFieldDesc(ActiveFieldId),
             this));


    editSField(ActiveFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleCursors         (void) const
{
    SFFieldContainerMap::GetHandlePtr returnValue(
        new  SFFieldContainerMap::GetHandle(
             &_sfCursors,
             this->getType().getFieldDesc(CursorsFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleCursors        (void)
{
    SFFieldContainerMap::EditHandlePtr returnValue(
        new  SFFieldContainerMap::EditHandle(
             &_sfCursors,
             this->getType().getFieldDesc(CursorsFieldId),
             this));


    editSField(CursorsFieldMask);

    return returnValue;
}

GetFieldHandlePtr UIDrawingSurfaceBase::getHandleCursorPosition  (void) const
{
    SFPnt2f::GetHandlePtr returnValue(
        new  SFPnt2f::GetHandle(
             &_sfCursorPosition,
             this->getType().getFieldDesc(CursorPositionFieldId),
             const_cast<UIDrawingSurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr UIDrawingSurfaceBase::editHandleCursorPosition (void)
{
    SFPnt2f::EditHandlePtr returnValue(
        new  SFPnt2f::EditHandle(
             &_sfCursorPosition,
             this->getType().getFieldDesc(CursorPositionFieldId),
             this));


    editSField(CursorPositionFieldMask);

    return returnValue;
}



#ifdef OSG_MT_CPTR_ASPECT
void UIDrawingSurfaceBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    UIDrawingSurface *pThis = static_cast<UIDrawingSurface *>(this);

    pThis->execSync(static_cast<UIDrawingSurface *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *UIDrawingSurfaceBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    UIDrawingSurface *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const UIDrawingSurface *>(pRefAspect),
                  dynamic_cast<const UIDrawingSurface *>(this));

    return returnValue;
}
#endif

void UIDrawingSurfaceBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<UIDrawingSurface *>(this)->clearInternalWindows();

    static_cast<UIDrawingSurface *>(this)->setFocusedWindow(NULL);

    static_cast<UIDrawingSurface *>(this)->setEventProducer(NULL);

    static_cast<UIDrawingSurface *>(this)->setGraphics(NULL);

    static_cast<UIDrawingSurface *>(this)->setMouseTransformFunctor(NULL);


}


OSG_END_NAMESPACE
