/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact:  David Kabala (djkabala@gmail.com)                             *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Tree!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"



#include "OSGTreeModel.h"               // Model Class
#include "OSGCellEditor.h"              // CellEditor Class
#include "OSGComponentGenerator.h"      // CellGenerator Class
#include "OSGTreeModelLayout.h"         // ModelLayout Class
#include "OSGTreeSelectionModel.h"      // SelectionModel Class

#include "OSGTreeBase.h"
#include "OSGTree.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Tree
    A UI Tree.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var TreeModel *     TreeBase::_sfModel
    
*/

/*! \var bool            TreeBase::_sfEditable
    Is the tree editable
*/

/*! \var bool            TreeBase::_sfExpandsSelectedPaths
    True if selection changes result in the parent path being expanded
*/

/*! \var bool            TreeBase::_sfInvokesStopCellEditing
    If true, when editing is to be stopped by way of selection changing, data in tree changing or other means stopCellEditing  is invoked, and changes are saved.
*/

/*! \var UInt32          TreeBase::_sfRowHeight
    Height to use for each display row.
*/

/*! \var bool            TreeBase::_sfScrollsOnExpand
    If true, when a node is expanded, as many of the descendants are scrolled to be visible.
*/

/*! \var bool            TreeBase::_sfShowsRootHandles
    True if handles are displayed at the topmost level of the tree.
*/

/*! \var UInt32          TreeBase::_sfToggleClickCount
    Number of mouse clicks before a node is expanded.
*/

/*! \var UInt32          TreeBase::_sfVisibleRowCount
    Number of rows to make visible at one time.
*/

/*! \var CellEditor *    TreeBase::_sfCellEditor
    
*/

/*! \var ComponentGenerator * TreeBase::_sfCellGenerator
    
*/

/*! \var TreeModelLayout * TreeBase::_sfModelLayout
    
*/

/*! \var TreeSelectionModel * TreeBase::_sfSelectionModel
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<Tree *>::_type("TreePtr", "ComponentContainerPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(Tree *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Tree *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Tree *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void TreeBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUnrecTreeModelPtr::Description(
        SFUnrecTreeModelPtr::getClassType(),
        "Model",
        "",
        ModelFieldId, ModelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleModel),
        static_cast<FieldGetMethodSig >(&Tree::getHandleModel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "Editable",
        "Is the tree editable\n",
        EditableFieldId, EditableFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleEditable),
        static_cast<FieldGetMethodSig >(&Tree::getHandleEditable));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "ExpandsSelectedPaths",
        "True if selection changes result in the parent path being expanded\n",
        ExpandsSelectedPathsFieldId, ExpandsSelectedPathsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleExpandsSelectedPaths),
        static_cast<FieldGetMethodSig >(&Tree::getHandleExpandsSelectedPaths));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "InvokesStopCellEditing",
        "If true, when editing is to be stopped by way of selection changing, data in tree changing or other means stopCellEditing  is invoked, and changes are saved.\n",
        InvokesStopCellEditingFieldId, InvokesStopCellEditingFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleInvokesStopCellEditing),
        static_cast<FieldGetMethodSig >(&Tree::getHandleInvokesStopCellEditing));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "RowHeight",
        "Height to use for each display row.\n",
        RowHeightFieldId, RowHeightFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleRowHeight),
        static_cast<FieldGetMethodSig >(&Tree::getHandleRowHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "ScrollsOnExpand",
        "If true, when a node is expanded, as many of the descendants are scrolled to be visible.\n",
        ScrollsOnExpandFieldId, ScrollsOnExpandFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleScrollsOnExpand),
        static_cast<FieldGetMethodSig >(&Tree::getHandleScrollsOnExpand));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "ShowsRootHandles",
        "True if handles are displayed at the topmost level of the tree.\n",
        ShowsRootHandlesFieldId, ShowsRootHandlesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleShowsRootHandles),
        static_cast<FieldGetMethodSig >(&Tree::getHandleShowsRootHandles));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "ToggleClickCount",
        "Number of mouse clicks before a node is expanded.\n",
        ToggleClickCountFieldId, ToggleClickCountFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleToggleClickCount),
        static_cast<FieldGetMethodSig >(&Tree::getHandleToggleClickCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "VisibleRowCount",
        "Number of rows to make visible at one time.\n",
        VisibleRowCountFieldId, VisibleRowCountFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleVisibleRowCount),
        static_cast<FieldGetMethodSig >(&Tree::getHandleVisibleRowCount));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecCellEditorPtr::Description(
        SFUnrecCellEditorPtr::getClassType(),
        "CellEditor",
        "",
        CellEditorFieldId, CellEditorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleCellEditor),
        static_cast<FieldGetMethodSig >(&Tree::getHandleCellEditor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecComponentGeneratorPtr::Description(
        SFUnrecComponentGeneratorPtr::getClassType(),
        "CellGenerator",
        "",
        CellGeneratorFieldId, CellGeneratorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleCellGenerator),
        static_cast<FieldGetMethodSig >(&Tree::getHandleCellGenerator));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecTreeModelLayoutPtr::Description(
        SFUnrecTreeModelLayoutPtr::getClassType(),
        "ModelLayout",
        "",
        ModelLayoutFieldId, ModelLayoutFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleModelLayout),
        static_cast<FieldGetMethodSig >(&Tree::getHandleModelLayout));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecTreeSelectionModelPtr::Description(
        SFUnrecTreeSelectionModelPtr::getClassType(),
        "SelectionModel",
        "",
        SelectionModelFieldId, SelectionModelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Tree::editHandleSelectionModel),
        static_cast<FieldGetMethodSig >(&Tree::getHandleSelectionModel));

    oType.addInitialDesc(pDesc);
}


TreeBase::TypeObject TreeBase::_type(
    TreeBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&TreeBase::createEmptyLocal),
    Tree::initMethod,
    Tree::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&Tree::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"Tree\"\n"
    "    parent=\"ComponentContainer\"\n"
    "    library=\"ContribUserInterface\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    authors=\"David Kabala (djkabala@gmail.com)                             \"\n"
    "    >\n"
    "    A UI Tree.\n"
    "    <Field\n"
    "        name=\"Model\"\n"
    "        type=\"TreeModel\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Editable\"\n"
    "        type=\"bool\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Is the tree editable\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ExpandsSelectedPaths\"\n"
    "        type=\"bool\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        True if selection changes result in the parent path being expanded\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"InvokesStopCellEditing\"\n"
    "        type=\"bool\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If true, when editing is to be stopped by way of selection changing, data in tree changing or other means stopCellEditing  is invoked, and changes are saved.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"RowHeight\"\n"
    "        type=\"UInt32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Height to use for each display row.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ScrollsOnExpand\"\n"
    "        type=\"bool\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If true, when a node is expanded, as many of the descendants are scrolled to be visible.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ShowsRootHandles\"\n"
    "        type=\"bool\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        True if handles are displayed at the topmost level of the tree.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ToggleClickCount\"\n"
    "        type=\"UInt32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Number of mouse clicks before a node is expanded.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"VisibleRowCount\"\n"
    "        type=\"UInt32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"10\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Number of rows to make visible at one time.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"CellEditor\"\n"
    "        type=\"CellEditor\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"CellGenerator\"\n"
    "        type=\"ComponentGenerator\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ModelLayout\"\n"
    "        type=\"TreeModelLayout\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"SelectionModel\"\n"
    "        type=\"TreeSelectionModel\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"NULL\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "    </Field>\n"
    "</FieldContainer>\n",
    "A UI Tree.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TreeBase::getType(void)
{
    return _type;
}

const FieldContainerType &TreeBase::getType(void) const
{
    return _type;
}

UInt32 TreeBase::getContainerSize(void) const
{
    return sizeof(Tree);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Tree::_sfModel field.
const SFUnrecTreeModelPtr *TreeBase::getSFModel(void) const
{
    return &_sfModel;
}

SFUnrecTreeModelPtr *TreeBase::editSFModel          (void)
{
    editSField(ModelFieldMask);

    return &_sfModel;
}

SFBool *TreeBase::editSFEditable(void)
{
    editSField(EditableFieldMask);

    return &_sfEditable;
}

const SFBool *TreeBase::getSFEditable(void) const
{
    return &_sfEditable;
}


SFBool *TreeBase::editSFExpandsSelectedPaths(void)
{
    editSField(ExpandsSelectedPathsFieldMask);

    return &_sfExpandsSelectedPaths;
}

const SFBool *TreeBase::getSFExpandsSelectedPaths(void) const
{
    return &_sfExpandsSelectedPaths;
}


SFBool *TreeBase::editSFInvokesStopCellEditing(void)
{
    editSField(InvokesStopCellEditingFieldMask);

    return &_sfInvokesStopCellEditing;
}

const SFBool *TreeBase::getSFInvokesStopCellEditing(void) const
{
    return &_sfInvokesStopCellEditing;
}


SFUInt32 *TreeBase::editSFRowHeight(void)
{
    editSField(RowHeightFieldMask);

    return &_sfRowHeight;
}

const SFUInt32 *TreeBase::getSFRowHeight(void) const
{
    return &_sfRowHeight;
}


SFBool *TreeBase::editSFScrollsOnExpand(void)
{
    editSField(ScrollsOnExpandFieldMask);

    return &_sfScrollsOnExpand;
}

const SFBool *TreeBase::getSFScrollsOnExpand(void) const
{
    return &_sfScrollsOnExpand;
}


SFBool *TreeBase::editSFShowsRootHandles(void)
{
    editSField(ShowsRootHandlesFieldMask);

    return &_sfShowsRootHandles;
}

const SFBool *TreeBase::getSFShowsRootHandles(void) const
{
    return &_sfShowsRootHandles;
}


SFUInt32 *TreeBase::editSFToggleClickCount(void)
{
    editSField(ToggleClickCountFieldMask);

    return &_sfToggleClickCount;
}

const SFUInt32 *TreeBase::getSFToggleClickCount(void) const
{
    return &_sfToggleClickCount;
}


SFUInt32 *TreeBase::editSFVisibleRowCount(void)
{
    editSField(VisibleRowCountFieldMask);

    return &_sfVisibleRowCount;
}

const SFUInt32 *TreeBase::getSFVisibleRowCount(void) const
{
    return &_sfVisibleRowCount;
}


//! Get the Tree::_sfCellEditor field.
const SFUnrecCellEditorPtr *TreeBase::getSFCellEditor(void) const
{
    return &_sfCellEditor;
}

SFUnrecCellEditorPtr *TreeBase::editSFCellEditor     (void)
{
    editSField(CellEditorFieldMask);

    return &_sfCellEditor;
}

//! Get the Tree::_sfCellGenerator field.
const SFUnrecComponentGeneratorPtr *TreeBase::getSFCellGenerator(void) const
{
    return &_sfCellGenerator;
}

SFUnrecComponentGeneratorPtr *TreeBase::editSFCellGenerator  (void)
{
    editSField(CellGeneratorFieldMask);

    return &_sfCellGenerator;
}

//! Get the Tree::_sfModelLayout field.
const SFUnrecTreeModelLayoutPtr *TreeBase::getSFModelLayout(void) const
{
    return &_sfModelLayout;
}

SFUnrecTreeModelLayoutPtr *TreeBase::editSFModelLayout    (void)
{
    editSField(ModelLayoutFieldMask);

    return &_sfModelLayout;
}

//! Get the Tree::_sfSelectionModel field.
const SFUnrecTreeSelectionModelPtr *TreeBase::getSFSelectionModel(void) const
{
    return &_sfSelectionModel;
}

SFUnrecTreeSelectionModelPtr *TreeBase::editSFSelectionModel (void)
{
    editSField(SelectionModelFieldMask);

    return &_sfSelectionModel;
}





/*------------------------------ access -----------------------------------*/

UInt32 TreeBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ModelFieldMask & whichField))
    {
        returnValue += _sfModel.getBinSize();
    }
    if(FieldBits::NoField != (EditableFieldMask & whichField))
    {
        returnValue += _sfEditable.getBinSize();
    }
    if(FieldBits::NoField != (ExpandsSelectedPathsFieldMask & whichField))
    {
        returnValue += _sfExpandsSelectedPaths.getBinSize();
    }
    if(FieldBits::NoField != (InvokesStopCellEditingFieldMask & whichField))
    {
        returnValue += _sfInvokesStopCellEditing.getBinSize();
    }
    if(FieldBits::NoField != (RowHeightFieldMask & whichField))
    {
        returnValue += _sfRowHeight.getBinSize();
    }
    if(FieldBits::NoField != (ScrollsOnExpandFieldMask & whichField))
    {
        returnValue += _sfScrollsOnExpand.getBinSize();
    }
    if(FieldBits::NoField != (ShowsRootHandlesFieldMask & whichField))
    {
        returnValue += _sfShowsRootHandles.getBinSize();
    }
    if(FieldBits::NoField != (ToggleClickCountFieldMask & whichField))
    {
        returnValue += _sfToggleClickCount.getBinSize();
    }
    if(FieldBits::NoField != (VisibleRowCountFieldMask & whichField))
    {
        returnValue += _sfVisibleRowCount.getBinSize();
    }
    if(FieldBits::NoField != (CellEditorFieldMask & whichField))
    {
        returnValue += _sfCellEditor.getBinSize();
    }
    if(FieldBits::NoField != (CellGeneratorFieldMask & whichField))
    {
        returnValue += _sfCellGenerator.getBinSize();
    }
    if(FieldBits::NoField != (ModelLayoutFieldMask & whichField))
    {
        returnValue += _sfModelLayout.getBinSize();
    }
    if(FieldBits::NoField != (SelectionModelFieldMask & whichField))
    {
        returnValue += _sfSelectionModel.getBinSize();
    }

    return returnValue;
}

void TreeBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ModelFieldMask & whichField))
    {
        _sfModel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EditableFieldMask & whichField))
    {
        _sfEditable.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExpandsSelectedPathsFieldMask & whichField))
    {
        _sfExpandsSelectedPaths.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InvokesStopCellEditingFieldMask & whichField))
    {
        _sfInvokesStopCellEditing.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RowHeightFieldMask & whichField))
    {
        _sfRowHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScrollsOnExpandFieldMask & whichField))
    {
        _sfScrollsOnExpand.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShowsRootHandlesFieldMask & whichField))
    {
        _sfShowsRootHandles.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ToggleClickCountFieldMask & whichField))
    {
        _sfToggleClickCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (VisibleRowCountFieldMask & whichField))
    {
        _sfVisibleRowCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CellEditorFieldMask & whichField))
    {
        _sfCellEditor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CellGeneratorFieldMask & whichField))
    {
        _sfCellGenerator.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ModelLayoutFieldMask & whichField))
    {
        _sfModelLayout.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SelectionModelFieldMask & whichField))
    {
        _sfSelectionModel.copyToBin(pMem);
    }
}

void TreeBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ModelFieldMask & whichField))
    {
        _sfModel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EditableFieldMask & whichField))
    {
        _sfEditable.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExpandsSelectedPathsFieldMask & whichField))
    {
        _sfExpandsSelectedPaths.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InvokesStopCellEditingFieldMask & whichField))
    {
        _sfInvokesStopCellEditing.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RowHeightFieldMask & whichField))
    {
        _sfRowHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScrollsOnExpandFieldMask & whichField))
    {
        _sfScrollsOnExpand.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShowsRootHandlesFieldMask & whichField))
    {
        _sfShowsRootHandles.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ToggleClickCountFieldMask & whichField))
    {
        _sfToggleClickCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (VisibleRowCountFieldMask & whichField))
    {
        _sfVisibleRowCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CellEditorFieldMask & whichField))
    {
        _sfCellEditor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CellGeneratorFieldMask & whichField))
    {
        _sfCellGenerator.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ModelLayoutFieldMask & whichField))
    {
        _sfModelLayout.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SelectionModelFieldMask & whichField))
    {
        _sfSelectionModel.copyFromBin(pMem);
    }
}

//! create a new instance of the class
TreeTransitPtr TreeBase::createLocal(BitVector bFlags)
{
    TreeTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Tree>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
TreeTransitPtr TreeBase::createDependent(BitVector bFlags)
{
    TreeTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Tree>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
TreeTransitPtr TreeBase::create(void)
{
    TreeTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Tree>(tmpPtr);
    }

    return fc;
}

Tree *TreeBase::createEmptyLocal(BitVector bFlags)
{
    Tree *returnValue;

    newPtr<Tree>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Tree *TreeBase::createEmpty(void)
{
    Tree *returnValue;

    newPtr<Tree>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr TreeBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Tree *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Tree *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr TreeBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Tree *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Tree *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr TreeBase::shallowCopy(void) const
{
    Tree *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Tree *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

TreeBase::TreeBase(void) :
    Inherited(),
    _sfModel                  (NULL),
    _sfEditable               (bool(false)),
    _sfExpandsSelectedPaths   (bool(false)),
    _sfInvokesStopCellEditing (bool(false)),
    _sfRowHeight              (UInt32(false)),
    _sfScrollsOnExpand        (bool(true)),
    _sfShowsRootHandles       (bool(true)),
    _sfToggleClickCount       (UInt32(2)),
    _sfVisibleRowCount        (UInt32(10)),
    _sfCellEditor             (NULL),
    _sfCellGenerator          (NULL),
    _sfModelLayout            (NULL),
    _sfSelectionModel         (NULL)
{
}

TreeBase::TreeBase(const TreeBase &source) :
    Inherited(source),
    _sfModel                  (NULL),
    _sfEditable               (source._sfEditable               ),
    _sfExpandsSelectedPaths   (source._sfExpandsSelectedPaths   ),
    _sfInvokesStopCellEditing (source._sfInvokesStopCellEditing ),
    _sfRowHeight              (source._sfRowHeight              ),
    _sfScrollsOnExpand        (source._sfScrollsOnExpand        ),
    _sfShowsRootHandles       (source._sfShowsRootHandles       ),
    _sfToggleClickCount       (source._sfToggleClickCount       ),
    _sfVisibleRowCount        (source._sfVisibleRowCount        ),
    _sfCellEditor             (NULL),
    _sfCellGenerator          (NULL),
    _sfModelLayout            (NULL),
    _sfSelectionModel         (NULL)
{
}


/*-------------------------- destructors ----------------------------------*/

TreeBase::~TreeBase(void)
{
}

void TreeBase::onCreate(const Tree *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Tree *pThis = static_cast<Tree *>(this);

        pThis->setModel(source->getModel());

        pThis->setCellEditor(source->getCellEditor());

        pThis->setCellGenerator(source->getCellGenerator());

        pThis->setModelLayout(source->getModelLayout());

        pThis->setSelectionModel(source->getSelectionModel());
    }
}

GetFieldHandlePtr TreeBase::getHandleModel           (void) const
{
    SFUnrecTreeModelPtr::GetHandlePtr returnValue(
        new  SFUnrecTreeModelPtr::GetHandle(
             &_sfModel,
             this->getType().getFieldDesc(ModelFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleModel          (void)
{
    SFUnrecTreeModelPtr::EditHandlePtr returnValue(
        new  SFUnrecTreeModelPtr::EditHandle(
             &_sfModel,
             this->getType().getFieldDesc(ModelFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Tree::setModel,
                    static_cast<Tree *>(this), _1));

    editSField(ModelFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleEditable        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfEditable,
             this->getType().getFieldDesc(EditableFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleEditable       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfEditable,
             this->getType().getFieldDesc(EditableFieldId),
             this));


    editSField(EditableFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleExpandsSelectedPaths (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfExpandsSelectedPaths,
             this->getType().getFieldDesc(ExpandsSelectedPathsFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleExpandsSelectedPaths(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfExpandsSelectedPaths,
             this->getType().getFieldDesc(ExpandsSelectedPathsFieldId),
             this));


    editSField(ExpandsSelectedPathsFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleInvokesStopCellEditing (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfInvokesStopCellEditing,
             this->getType().getFieldDesc(InvokesStopCellEditingFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleInvokesStopCellEditing(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfInvokesStopCellEditing,
             this->getType().getFieldDesc(InvokesStopCellEditingFieldId),
             this));


    editSField(InvokesStopCellEditingFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleRowHeight       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfRowHeight,
             this->getType().getFieldDesc(RowHeightFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleRowHeight      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfRowHeight,
             this->getType().getFieldDesc(RowHeightFieldId),
             this));


    editSField(RowHeightFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleScrollsOnExpand (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfScrollsOnExpand,
             this->getType().getFieldDesc(ScrollsOnExpandFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleScrollsOnExpand(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfScrollsOnExpand,
             this->getType().getFieldDesc(ScrollsOnExpandFieldId),
             this));


    editSField(ScrollsOnExpandFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleShowsRootHandles (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfShowsRootHandles,
             this->getType().getFieldDesc(ShowsRootHandlesFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleShowsRootHandles(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfShowsRootHandles,
             this->getType().getFieldDesc(ShowsRootHandlesFieldId),
             this));


    editSField(ShowsRootHandlesFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleToggleClickCount (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfToggleClickCount,
             this->getType().getFieldDesc(ToggleClickCountFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleToggleClickCount(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfToggleClickCount,
             this->getType().getFieldDesc(ToggleClickCountFieldId),
             this));


    editSField(ToggleClickCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleVisibleRowCount (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfVisibleRowCount,
             this->getType().getFieldDesc(VisibleRowCountFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleVisibleRowCount(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfVisibleRowCount,
             this->getType().getFieldDesc(VisibleRowCountFieldId),
             this));


    editSField(VisibleRowCountFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleCellEditor      (void) const
{
    SFUnrecCellEditorPtr::GetHandlePtr returnValue(
        new  SFUnrecCellEditorPtr::GetHandle(
             &_sfCellEditor,
             this->getType().getFieldDesc(CellEditorFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleCellEditor     (void)
{
    SFUnrecCellEditorPtr::EditHandlePtr returnValue(
        new  SFUnrecCellEditorPtr::EditHandle(
             &_sfCellEditor,
             this->getType().getFieldDesc(CellEditorFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Tree::setCellEditor,
                    static_cast<Tree *>(this), _1));

    editSField(CellEditorFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleCellGenerator   (void) const
{
    SFUnrecComponentGeneratorPtr::GetHandlePtr returnValue(
        new  SFUnrecComponentGeneratorPtr::GetHandle(
             &_sfCellGenerator,
             this->getType().getFieldDesc(CellGeneratorFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleCellGenerator  (void)
{
    SFUnrecComponentGeneratorPtr::EditHandlePtr returnValue(
        new  SFUnrecComponentGeneratorPtr::EditHandle(
             &_sfCellGenerator,
             this->getType().getFieldDesc(CellGeneratorFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Tree::setCellGenerator,
                    static_cast<Tree *>(this), _1));

    editSField(CellGeneratorFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleModelLayout     (void) const
{
    SFUnrecTreeModelLayoutPtr::GetHandlePtr returnValue(
        new  SFUnrecTreeModelLayoutPtr::GetHandle(
             &_sfModelLayout,
             this->getType().getFieldDesc(ModelLayoutFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleModelLayout    (void)
{
    SFUnrecTreeModelLayoutPtr::EditHandlePtr returnValue(
        new  SFUnrecTreeModelLayoutPtr::EditHandle(
             &_sfModelLayout,
             this->getType().getFieldDesc(ModelLayoutFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Tree::setModelLayout,
                    static_cast<Tree *>(this), _1));

    editSField(ModelLayoutFieldMask);

    return returnValue;
}

GetFieldHandlePtr TreeBase::getHandleSelectionModel  (void) const
{
    SFUnrecTreeSelectionModelPtr::GetHandlePtr returnValue(
        new  SFUnrecTreeSelectionModelPtr::GetHandle(
             &_sfSelectionModel,
             this->getType().getFieldDesc(SelectionModelFieldId),
             const_cast<TreeBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TreeBase::editHandleSelectionModel (void)
{
    SFUnrecTreeSelectionModelPtr::EditHandlePtr returnValue(
        new  SFUnrecTreeSelectionModelPtr::EditHandle(
             &_sfSelectionModel,
             this->getType().getFieldDesc(SelectionModelFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Tree::setSelectionModel,
                    static_cast<Tree *>(this), _1));

    editSField(SelectionModelFieldMask);

    return returnValue;
}



#ifdef OSG_MT_CPTR_ASPECT
void TreeBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Tree *pThis = static_cast<Tree *>(this);

    pThis->execSync(static_cast<Tree *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *TreeBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Tree *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Tree *>(pRefAspect),
                  dynamic_cast<const Tree *>(this));

    return returnValue;
}
#endif

void TreeBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Tree *>(this)->setModel(NULL);

    static_cast<Tree *>(this)->setCellEditor(NULL);

    static_cast<Tree *>(this)->setCellGenerator(NULL);

    static_cast<Tree *>(this)->setModelLayout(NULL);

    static_cast<Tree *>(this)->setSelectionModel(NULL);


}


OSG_END_NAMESPACE
